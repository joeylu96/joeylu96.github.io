---
title: 存储管理_2
author: joeylu
date: 2020-12-21 21:20:00 +0800
categories: [学习, 操作系统]
tags: [操作系统]
toc: false
---
# Linux进程与存储管理
**1.进程与存储概述:**  
&ensp;&ensp;&ensp;&ensp;linux操作系统只有在其内核装入内存后才能开始运行。为了使内核在开机时顺利装入
内存，用户必须将linux操作系统的执行代码以文件方式存储在计算机硬盘设备中，并对计算机系统中的其他资源
进行初始化，此过程为操作系统的安装。当安装好后，计算机电源开，系统引导程序将外存硬盘中的操作系统核心
加载到内存，然后进行linux核心的初始化，设置和初始化各种数据结构和表格，初始化linux核心和各个子系统的过程。
这一过程从进程角度来说，首先建立linux系统中唯一一个静态建立的进程（0#进程或idle进程），之后创建控制终端进程
和运行shell的init进程（1#）。linux系统中通过请求操作系统服务进入核心态的机制称为系统调用。  
  
**2.Linux进程调度:**  
&ensp;&ensp;&ensp;&ensp;调度模块分配CPU，按照进程的优先级，每次调度最高优先级的进程去占有处理机。每个进程
在创建时就有一个随时间动态变化的优先级，调度过程schedule()和时钟中断都会修改这个优先级。引起进程调度的情况为:  
&ensp;&ensp;&ensp;&ensp;1.当前执行进程申请系统资源时未得到满足，调用sleep，放弃处理机而进入睡眠。  
&ensp;&ensp;&ensp;&ensp;2.因并发进程而调用wait，放弃处理机而进入睡眠。  
&ensp;&ensp;&ensp;&ensp;3.当某个进程被唤醒，且它的优先级高于当前进程以及当前进程时间片用完时，系统设置
调度标志need_resched，并不立即调度，在系统核心态执行完毕后，由核心态转用户态时，check调度标志并进行调度。  
&ensp;&ensp;&ensp;&ensp;4.当前进程调用exit，自我终止。  
  
**3.Linux进程结构:**  
&ensp;&ensp;&ensp;&ensp;Linux进程中，进程特性为：1.一个进程是对一个程序的执行 2.一个进程意味着一个task_struct结构的存在，
它包含着进程控制信息 3.一个进程可以生成或消灭其子进程 4.一个进程是获得和释放各种系统资源的基本单位。  
  
&ensp;&ensp;&ensp;&ensp;task_struct：该结构相当于PCB进程控制块，它包含进程状态位，进程标识号，描述进程家族的
一些指针，若干用户标识号（包括UID和GID）,调度参数（优先数，调度策略等参数），软中断信号项，中断和软中断处理相关的参数，
各种计时项（给出执行时间和资源利用情况），进程地址空间和内存关系有关的信息，与文件系统相关的fs_struct，用户文件描述符表，
进程消亡时的返回值和终止信号，上下文切换相关的各项和资源限制有关的各项。  
  
&ensp;&ensp;&ensp;&ensp;进程的虚拟地址结构：Linux将用户进程的所有地址空间有关的信息存在mm_struct的数据结构中，
该数据结构自身则保存在task_struct进程描述符中。正文，数据和栈分别存在各个虚拟区域中,称为vm_area,对应数据
结构为vm_area_struct，它包含：1.该区的起址和结束地址 2.区的标志位，一些区的属性 3.共享区域指针 4.文件系统指针 5.此区域的操作函数指针  

&ensp;&ensp;&ensp;&ensp;进程上下文由task_struct结构，用户栈和核心栈的内容，用户地址空间的正文段、数据段、
硬件寄存器的内容以及页表等组成。  
  
&ensp;&ensp;&ensp;&ensp;进程有6种基本状态：1.TASK_RUNNING，运行状态 2.TASK_INTERRUPTIBLE，进程正在睡眠，可中断状态 3.TASK_UNINTERRUPTIBLE，不可中断状态
（这里的中断指软中断，软中断是利用硬件中断的概念，用软件方式进行模拟，实现宏观上的异步执行效果，和信号类似。而硬中断是外部设备对CPU的中断） 
4.TASK_STOPPED，暂停状态 5.TASK_TRACE,表示进程被debugger等进程监视 6.TASK_ZOMBIE，进程执行了系统调用exit后，进入僵死状态。如下图  
![joey 图标](/assets/img/sample/5_1.jpg)  

**4.Linux进程控制:**  
&ensp;&ensp;&ensp;&ensp;进程控制包含创建，执行和自我终止，对应系统调用为fork，exec和exit。  
  
&ensp;&ensp;&ensp;&ensp;进程的创建，fork系统调用的功能为创建一个子进程，调用fork的进程为父进程。系统调用
fork通过执行核心程序fork过程完成的功能如下：1.为子进程分配一个进程描述符task_struct结构，将父进程的描述符内容
复制到新创建的结构仲，并重新设置那些与父进程不同的数据。 2.为子进程分配一个唯一的进程标识符pid 3.将父进程
的地址空间的逻辑副本复制到子进程（写时复制） 4.复制与父进程相关联的文件系统的数据结构和用户文件描述符表  5.复制软中断
信号有关的数据结构 6.设置子进程的状态为TASK_RUNNING 7.对父进程返回子进程的pid，子进程返回0
  
&ensp;&ensp;&ensp;&ensp;进程的执行，系统调用exec引出另一个程序，它用一个可执行文件的副本覆盖调用进程
的正文段和数据段，并以调用进程提供的参数去执行这个新的正文段程序。  
  
&ensp;&ensp;&ensp;&ensp;进程的终止，系统调用exit自我终止当前进程，进入ZOMBIE状态，等待父进程进行善后处理。  

**5.Linux进程调度:**  
&ensp;&ensp;&ensp;&ensp;Linux系统的进程调度是基于时间片加优先级的，系统为进程分配一个时间片，用完时，
动态计算该进程的优先级，若优先级高于当前内存就绪状态的进程，则系统设置调度标识，在核心态转换到用户态时，
由schedule()过程调度优先级高的进程执行，并把被抢先的进程保存到就绪队列中。进程调度按时间片计算优先级，并
按优先级的高低来调度进程抢占处理机。  

&ensp;&ensp;&ensp;&ensp;调度时机：1.进程自动放弃处理机时主动转入调度过程 2.核心态转入用户态时，系统设置了
高优先级就绪进程的强迫调度标识need_schedule时发生调度。皆为schedule()过程。  

&ensp;&ensp;&ensp;&ensp;调度标识的设置，当前进程的need_schedule何时会被设置为1：1.运行态的进程的时间片耗尽时 2.某个进程
被唤醒时，而它的优先级比正在执行的当前进程的优先级高时 3.当一个进程通过系统调用改变调度政策和nice值时  

&ensp;&ensp;&ensp;&ensp;调度策略：  
&ensp;&ensp;&ensp;&ensp;1.动态优先级数调度，适用于普通进程。通过goodness()函数计算进程的优先级，从内存就绪队列中选取优先级数最大的进程
投入执行，函数中weight=counter+priority-nice。counter是进程可用的时间片的动态优先级，进程创建时，父进程的counter
值会被平分为两部分，分别给自己和子进程。时间中断时，当前进程的counter值减少，这样就降低了正在运行中的
进程的优先级，使处于就绪队列的低优先级进程得到了运行机会。当所有非等待队列的进程的时间片用完时，其对应的counter为减为0，
调度程序会重新计算所有进程的counter，counter=counter/2+nice，为等待或睡眠进程周期性提升优先级。priority是一个常数20，
nice是系统允许用户设置的的进程优先数偏移值，默认为0，可调-20~19。  
&ensp;&ensp;&ensp;&ensp;2.对于实时进程来说，总的思想是为实时进程赋予远大于普通进程的固定权重参数weight，以确保实时进程
的优先级。在此基础上，还分为两种做法：一种与时间片无关，另一种与时间片有关；对于普通进程来说，原则上以相等的weight作为
所有进程的初始权重值，即nice=0，然后在每次进行进程调度时，根据剩余时间片对weight动态调整。实时进程的调度策略分为：
轮转法SCHED_RR和先来先服务法SCHED_FIFO  
  
&ensp;&ensp;&ensp;&ensp;调度实现：1.遍历实时进程，若为SCHED_RR，且时间片用完，则重新为其分配时间片并
移至队列尾，若进程状态为TASK_INTERRUPTIBLE可中断且收到了软中断信号，则将其分配为就绪状态。如果所有进程的
时间片用完则重新计算时间片。找到优先数最高的进程。 2.进程切换，上下文切换，用户进程的地址空间由switch_mm()完成，
进程的堆栈切换由switch_to()实现。  

**6.Linux进程通信:**  
&ensp;&ensp;&ensp;&ensp;1.低级通信，通过文件锁和软中断信号机制进行通信。  
&ensp;&ensp;&ensp;&ensp;2.进程间通信机制IPC，组成部分为：消息，共享存储器和信号量。消息用于进程之间
传递分类的格式化数据。共享存储器使得不同进程通过共享批彼此的虚拟空间而达到数据通信。信号量机制用于
通信进程之间的同步控制。  

**7.Linux存储管理:**  
&ensp;&ensp;&ensp;&ensp;Linux操作系统最低限度地使用分段机制，分页机制已经足以满足Linux对内存管理的需求，
地址空间被分页单元划分为4KB为1页的线性数组，分页单元以页面为最小处理单元，32位的虚拟地址的值被分为
3个部分，页目录地址、页表地址和页内地址。分页单元通过CR3寄存器找到页目录表的基地址，虚拟地址中页表地址作为页表
的偏移量访问到页表的基地址，虚拟地址中的页表地址作为页表的偏移量从而访问到页面的基地址，根据虚拟地址中
的页内地址找到对应的物理地址。  
  
&ensp;&ensp;&ensp;&ensp;缺页异常时，Linux的缺页异常处理过程被调用，判断地址所属的虚拟区域是否非法，若非法则向
进程发送SIGSEGV信号终止进程，否则则进入请求调页处理过程。
&ensp;&ensp;&ensp;&ensp;请求调页处理过程中，当页表有效位P=0时，访问的页不在内存中，有三种情况：1.页面被首次访问 
2.该页在外存中 3.该页在外存交换区中。前两种情况整个页表项为0，判断其虚拟区域是否在磁盘中，若是则为第二种
情况，反之为第一种。第一种情况涉及写时复制机制，进程创建页时，Linux并不为其分配物理内存，这段地址空间的内容
全部为0，是把一个内核初始化时静态分配的特殊页面映射到该页面地址，同时设置页的保护位为只读，当试图写这个页面时，
缺页异常处理会判断该页面是否是共享的，若是则重新分配页面并复制内容然后设置页的保护标志为可读的。第三种
情况涉及交换缓冲、页面换出过程和反向映射。  